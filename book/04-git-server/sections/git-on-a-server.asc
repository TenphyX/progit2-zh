[[_git_on_the_server]]
=== 在服务器上部署 Git

现在我们来讲讲怎么在你自己的服务器上部署Git服务跑之前谈到的协议。

[NOTE]
====
接下来我们会演示一些命令和步骤。这些命令和步骤可以在 Linux 服务器上完成一个简单基本的安装。尽管这些服务也可以运行在 Mac 或 Windows 服务器上。
事实上，在你的 IT 基础架构上搭建一个生产服务器肯定会存在一些安全措施或系统工具的不一样。但是希望本节可以给你一个笼统的概念，了解会涉及些什么。
====

为了开始搭建任何的 Git 服务器，需要导出一个已有的仓库为一个新的裸仓库——一个不包含工作目录的仓库。
做起来大体上是简单明了的。
克隆你的仓库来创建一个裸仓库，你可以运行加上 `--bare` 的克隆命令。(((git commands, clone, bare)))
按照惯例, 裸仓库的文件目录名以 `.git`结束，就是：

[source,console]
----
$ git clone --bare my_project my_project.git
Cloning into bare repository 'my_project.git'...
done.
----

现在 `my_project.git` 目录中已经有了一份 Git 目录数据的副本。

上面的命令大致相当于下面的命令：

[source,console]
----
$ cp -Rf my_project/.git my_project.git
----

但在配置文件中有若干小改动，不过对用户来讲，效果都差不多。
它会把 Git 仓库单独拿出来，抛弃工作目录，之后再专门为它创建一个目录存放。

[[_bare_repo]]
==== 把裸仓库移到服务器上

既然已经有了该仓库的裸副本，你所需要做的就是把它放在服务器上，再配置好协议。
假设说，你已经搭建好了一台服务器叫 `git.example.com` ，而且也可以 SSH 连接上去，现在想将所有的 Git 仓库存放在 `/opt/git` 目录下。
如果说 `/opt/git` 已经存在在那台服务器上了，你可以通过直接复制裸仓库来建立你的新仓库：

[source,console]
----
$ scp -r my_project.git user@git.example.com:/opt/git
----

到这一阶段，其它可以通过 SSH 访问的用户也同时对 `/opt/git` 有读取权限的话，可以用下面的命令克隆你的仓库：

[source,console]
----
$ git clone user@git.example.com:/opt/git/my_project.git
----

如果一个用户 SSH 连接到那台服务器，而且同时具有对 `/opt/git/my_project.git` 写入的权限，他就自然也就有了推送的权限。

如果你运行 `git init` 时加上 `--shared`选项，Git 会自动正确地添加用户组的写入权限到一个仓库。(((git commands, init, bare)))

[source,console]
----
$ ssh user@git.example.com
$ cd /opt/git/my_project.git
$ git init --bare --shared
----

我们已经看到这是多么简单，只需要取出 Git 仓库，创建一个裸版本，再把这个裸版本放到你和你的合作者们有 SSH 权限的服务器上。
现在你已经准备好在这项目上合作了。

要着重说明一下，下面就是为了运行一个可供若干人使用的 Git 服务器所需要的全部工作——在服务器上添加 SSH 账号，把一个裸仓库放在一个所有合作者有读写权限的地方。
搞定——别的什么都不需要了。

在接下来的几节当中，你会了解到怎么样去扩展至更精细的配置。
这些讨论会包括省去为用户逐一建立账号，开放仓库的读取权限，配置网页交互界面，使用 Gitosis 工具等等。
然而请记住，如果是跟几个人去协作一个私有项目，你所 _需要_ 的是一个 SSH 服务器和一个裸仓库。

==== 小型配置

如果是一个小型机构或者只是在你的组织里尝试 Git，开发人员也不是很多，那么事情对你来说可以变得简单。
配置一个 Git 服务器最复杂的方面之一是用户管理。
如果你想实现一个仓库对特定用户只读，而对别的用户可以读写，那么设置访问方式和权限可能会有点麻烦。

===== SSH 访问

(((serving repositories, SSH)))
如果已经有一个服务器，所有开发人员都对它有 SSH 访问权限，通常来说把你的第一个仓库放置在那里是最简单的。因为你几乎不用做什么 （就像我们上一节说的一样）。
如果想对仓库实施更复杂的访问控制类型权限，你可以通过服务器运行的操作系统的正常文件系统权限控制来实现。


We assume that if you have a server with which to do this, you already have an SSH server installed, and that's how you're accessing the server.

There are a few ways you can give access to everyone on your team.
The first is to set up accounts for everybody, which is straightforward but can be cumbersome.
You may not want to run `adduser` and set temporary passwords for every user.

A second method is to create a single 'git' user on the machine, ask every user who is to have write access to send you an SSH public key, and add that key to the `~/.ssh/authorized_keys` file of your new 'git' user.
At that point, everyone will be able to access that machine via the 'git' user.
This doesn't affect the commit data in any way – the SSH user you connect as doesn't affect the commits you've recorded.

Another way to do it is to have your SSH server authenticate from an LDAP server or some other centralized authentication source that you may already have set up.
As long as each user can get shell access on the machine, any SSH authentication mechanism you can think of should work.

=== The Protocols 协议

Git can use four major protocols to transfer data: Local, HTTP, Secure Shell (SSH) and Git.
Here we'll discuss what they are and in what basic circumstances you would want (or not want) to use them.
Git 可以使用四种主要的协议来传输数据：本地传输，HTTP 协议，SSH 协议，和Git 协议。下面分别介绍一下这些协议以及使用（或不使用）这些协议的情形。

==== Local Protocol 本地传输协议

(((protocols, local)))
The most basic is the _Local protocol_, in which the remote repository is in another directory on disk.
This is often used if everyone on your team has access to a shared filesystem such as an NFS mount, or in the less likely case that everyone logs in to the same computer.
The latter wouldn't be ideal, because all your code repository instances would reside on the same computer, making a catastrophic loss much more likely.
最基本的就是本地协议（Local protocol），所谓的远程仓库在该协议中的表示，就是硬盘上的另一个目录。这常见于团队所有成员都对一个共享的网络存储（例如 NFS）拥有访问权，或者比较少见的多人共同登陆到同一台电脑的情况。后面一种情况并不理想，因为所有代码仓库实例都储存在同一台电脑里，更可能造成灾难性的数据损失。

If you have a shared mounted filesystem, then you can clone, push to, and pull from a local file-based repository.
To clone a repository like this or to add one as a remote to an existing project, use the path to the repository as the URL.
For example, to clone a local repository, you can run something like this:
如果你使用一个共享的文件系统，就可以从一个本地文件系统中克隆、推送和获取仓库。这种情况下克隆远程仓库或者为现有本地仓库添加远程仓库只需要使用远程仓库的路径，示例如下：

[source,console]
----
$ git clone /opt/git/project.git
----

或:

[source,console]
----
$ git clone file:///opt/git/project.git
----

Git operates slightly differently if you explicitly specify `file://` at the beginning of the URL.
If you just specify the path, Git tries to use hardlinks or directly copy the files it needs.
If you specify `file://`, Git fires up the processes that it normally uses to transfer data over a network which is generally a lot less efficient method of transferring the data.
The main reason to specify the `file://` prefix is if you want a clean copy of the repository with extraneous references or objects left out – generally after an import from another version-control system or something similar (see <<_git_internals>> for maintenance tasks).
We'll use the normal path here because doing so is almost always faster.
如果在 URL 开头显式声明 “file://” ，那么 Git 的运行方式会稍微不一样。如果你只给出路径，Git 会尝试使用硬链接或直接复制它所需要的文件。如果使用了“file://”，Git 会调用它平时通过网络来传输数据的工序，而这种方式的效率相对较低。使用“file://”前缀的主要原因是你想抛弃原来仓库的无关引用或对象，来得到一个干净的仓库副本 —— 一般指从其他版本控制系统导入的，或类似情形（参见第 10 章“深入解析Git”的维护任务）。

我们这里仅仅使用普通路径，这样更快。

To add a local repository to an existing Git project, you can run something like this:
要添加一个本地仓库作为现有 Git 项目的远程仓库，可以这样做：

[source,console]
----
$ git remote add local_proj /opt/git/project.git
----

Then, you can push to and pull from that remote as though you were doing so over a network.
然后就可以向这个远程远程仓库推送和获取数据了，像在网络上一样。

===== The Pros 优点

The pros of file-based repositories are that they're simple and they use existing file permissions and network access.
If you already have a shared filesystem to which your whole team has access, setting up a repository is very easy.
You stick the bare repository copy somewhere everyone has shared access to and set the read/write permissions as you would for any other shared directory.
We'll discuss how to export a bare repository copy for this purpose in <<_git_on_the_server>>.
基于文件仓库的优点在于它的简单，同时保留了现存的文件权限和网络访问权限。如果你的团队已经有一个共享的网络存储，建立仓库就十分容易了。你只需把一份裸仓库的副本放在大家都能访问的地方，然后像对其他共享目录一样设置读写权限就可以了。我们将在下一节“在服务器上部署 Git”中讨论如何导出一个裸仓库的副本。

This is also a nice option for quickly grabbing work from someone else's working repository.
If you and a co-worker are working on the same project and they want you to check something out, running a command like `git pull /home/john/project` is often easier than them pushing to a remote server and you pulling down.
这也是从别人工作仓库中获取工作成果的快捷方法。假如你和你的同事在一个项目中合作，他们想让你检出一些东西的时候，运行类似 “git pull /home/john/project” 通常会比他们推送到服务器，而你再从服务器获取简单得多。

===== The Cons 缺点

The cons of this method are that shared access is generally more difficult to set up and reach from multiple locations than basic network access.
If you want to push from your laptop when you're at home, you have to mount the remote disk, which can be difficult and slow compared to network-based access.
这种方法的缺点是，与基本的网络连接访问相比，难以控制访问权限，也难以从多个位置来访问。如果你想从家里的笔记本电脑上推送，就要先挂载远程硬盘，这和基于网络连接的访问相比更加困难和缓慢。

It's also important to mention that this isn't necessarily the fastest option if you're using a shared mount of some kind.
A local repository is fast only if you have fast access to the data.
A repository on NFS is often slower than the repository over SSH on the same server, allowing Git to run off local disks on each system.
另一个很重要的问题是该方法不一定就是最快的，尤其是对于共享挂载的文件系统。本地仓库只有在你对数据访问速度快的时候才快。对同一个服务器而言，如果NFS和SSH都可以让Git访问本地硬盘，通过NFS访问仓库通常会比SSH慢。

==== The HTTP Protocols HTTP 协议

Git can communicate over HTTP in two different modes.
Prior to Git 1.6.6 there was only one way it could do this which was very simple and generally read-only.
In version 1.6.6 a new, smarter protocol was introduced that involved Git being able to intelligently negotiate data transfer in a manner similar to how it does over SSH.
In the last few years, this new HTTP protocol has become very popular since it's simpler for the user and smarter about how it communicates.
The newer version is often referred to as the ``Smart'' HTTP protocol and the older way as ``Dumb'' HTTP.
We'll cover the newer ``smart'' HTTP protocol first.
Git 能使用两种模式通过HTTP通讯。在Git 1.6.6之前的版本，只存在一种非常简单的只读方式。在Git 1.6.6中，一种新的智能的协议被引入，这样Git就能智能地协商数据传输，类似于它使用SSH的方式。因为它对用户来说更为简单，而且在通讯的时候更智能，在过去的几年中这种新的HTTP协议变得非常流行。这一新协议通常被称为智能HTTP（“Smart HTTP”），之前的协议被称为傻瓜HTTP（“Dumb HTTP”）。
我们先介绍这种新的智能HTTP协议。

===== Smart HTTP

(((protocols, smart HTTP)))
The ``smart'' HTTP protocol operates very similarly to the SSH or Git protocols but runs over standard HTTP/S ports and can use various HTTP authentication mechanisms, meaning it's often easier on the user than something like SSH, since you can use things like username/password basic authentication rather than having to set up SSH keys.
智能HTTP协议在操作上非常类似于SSH和Git协议，只不过是通过HTTP/S端口传输，而且可以使用多样的HTTP认证机制。这意味着相对于SSH，用户使用起来更容易。用户可以使用用户名、密码组合这样的基本认证方式，而不是非得设置SSH密钥对。

It has probably become the most popular way to use Git now, since it can be set up to both serve anonymously like the `git://` protocol, and can also be pushed over with authentication and encryption like the SSH protocol. Instead of having to set up different URLs for these things, you can now use a single URL for both. If you try to push and the repository requires authentication (which it normally should), the server can prompt for a username and password. The same goes for read access.
现在这可能已经称为使用Git最流行的方式了。因为它可以设置为同时接受匿名请求，就像“Git://”协议；也可以设置为像SSH协议一样，通过认证推送并加密。你现在可以为两种方式使用同一个URL链接，而不用分别设置为两个不一样的URL链接。如果你尝试推送到一个要求认证的仓库（通常它应该要求认证），服务器会弹出输入用户名和密码的提示。读取也是一样。

In fact, for services like GitHub, the URL you use to view the repository online (for example, ``https://github.com/schacon/simplegit[]'') is the same URL you can use to clone and, if you have access, push over.
事实上，对于像GitHub一样的服务来说，你在线查看仓库的URL链接（比如“https://github.com/schacon/simplegit[]”）就是你用来克隆和推送的链接（如果你有相应权限的话）。

===== Dumb HTTP 傻瓜HTTP

(((protocols, dumb HTTP)))
If the server does not respond with a Git HTTP smart service, the Git client will try to fall back to the simpler ``dumb'' HTTP protocol.
The Dumb protocol expects the bare Git repository to be served like normal files from the web server.
The beauty of the Dumb HTTP protocol is the simplicity of setting it up.
Basically, all you have to do is put a bare Git repository under your HTTP document root and set up a specific `post-update` hook, and you're done (See <<_git_hooks>>).
At that point, anyone who can access the web server under which you put the repository can also clone your repository.
To allow read access to your repository over HTTP, do something like this:
如果服务器没有Git智能HTTP服务响应，Git客户端会尝试回落到更简单的傻瓜HTTP协议。傻瓜HTTP协议把裸Git仓库当作那台Web服务器上的普通文件处理。傻瓜HTTP协议的美好之处在于设置它非常简单。基本上，你所需要做的一切就是放一个裸Git仓库到你的HTTP文档根目录，设置明确的`post-update`钩子，搞定（参见第 8 章的“Git钩子”<<_git_hooks>>）。到这一阶段，任何有权限访问这台你存放仓库的Web服务器的人就可以克隆你的仓库了。如果要开放你的仓库的只读权限，这样做：

[source,console]
----
$ cd /var/www/htdocs/
$ git clone --bare /path/to/git_project gitproject.git
$ cd gitproject.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update
----

That's all.(((hooks, post-update)))
The `post-update` hook that comes with Git by default runs the appropriate command (`git update-server-info`) to make HTTP fetching and cloning work properly.
This command is run when you push to this repository (over SSH perhaps); then, other people can clone via something like
仅此而已。(((hooks, post-update)))
Git中默认的`post-update`钩子运行恰当的命令（`git update-server-info`）来使HTTP抓取和克隆正常运行。当你推送到这个仓库的时候（可能是通过SSH），这个命令会运行；之后，别人就可以通过类似于下面的方式克隆。

[source,console]
----
$ git clone https://example.com/gitproject.git
----

In this particular case, we're using the `/var/www/htdocs` path that is common for Apache setups, but you can use any static web server – just put the bare repository in its path.
The Git data is served as basic static files (see <<_git_internals>> for details about exactly how it's served).
在这个例子里面，我们使用了`/var/www/htdocs`这个路径，这对于Apache来说是常见的。当然你也可以使用任何别的静态Web服务器，只需要将裸仓库放到它的路径里。Git数据只是被当作简单静态文件（关于更多细节，参见第 10 章“深入解析Git”）。

Generally you would either choose to run a read/write Smart HTTP server or simply have the files accessible as read-only in the Dumb manner. It's rare to run a mix of the two services.
大体上来说，你可以选择运行一个可以读写的智能HTTP服务器或者简单地将这些文件用傻瓜方式以只读权限发布出去。很少有人同时混合使用这两种方式。

===== The Pros 优点

We'll concentrate on the pros of the Smart version of the HTTP protocol.
我们着重说智能HTTP的优点。

The simplicity of having a single URL for all types of access and having the server prompt only when authentication is needed makes things very easy for the end user.
Being able to authenticate with a username and password is also a big advantage over SSH, since users don't have to generate SSH keys locally and upload their public key to the server before being able to interact with it.
For less sophisticated users, or users on systems where SSH is less common, this is a major advantage in usability.
It is also a very fast and efficient protocol, similar to the SSH one.
为所有访问类型使用单一的URL链接，而且仅当需要认证时服务器才弹出提示。对最终用户来说，这样使事情变得简单了。可以使用用户名密码进行认证也是相对于SSH的一个巨大优势。这样用户就不需要为了跟它交互而在本地生成SSH密钥并上传相应的公钥到服务器。对于不那么老练的用户，或者在一些使用SSH并不普遍的系统上，这是可用性上的一个重大优势。它同时也是非常迅速且高效的协议，这一点类似于SSH协议。

You can also serve your repositories read-only over HTTPS, which means you can encrypt the content transfer; or you can go so far as to make the clients use specific signed SSL certificates.
你也可以通过HTTPS提供你的只读仓库，这意味着你可以加密传输内容；或者你可以更进一步要求客户端使用特定签名的SSL证书。

Another nice thing is that HTTP/S are such commonly used protocols that corporate firewalls are often set up to allow traffic through these ports.
HTTP/S 还有另外一个好处：它是一个如此常用的协议，所以企业防火墙通常都设置为允许通过其端口的通信。

===== The Cons 缺点

Git over HTTP/S can be a little more tricky to set up compared to SSH on some servers.
Other than that, there is very little advantage that other protocols have over the ``Smart'' HTTP protocol for serving Git.
与配置SSH相比，在某些服务器上配置使用HTTP/S的Git可能会更棘手一些。除此之外，在提供Git服务的方面，别的协议相对于智能HTTP几乎没有别的优势。

If you're using HTTP for authenticated pushing, providing your credentials is sometimes more complicated than using keys over SSH. There are however several credential caching tools you can use, including Keychain access on OSX and Credential Manager on Windows, to make this pretty painless. Read <<_credential_caching>> to see how to set up secure HTTP password caching on your system.
如果你使用HTTP来进行认证后推送，倘若你的凭证复杂程度超过SSH的密钥对，你可以使用一些凭证缓存的工具，比如：OS X上的Keychain和Windows上的凭据管理器。这样痛苦就减轻很多。关于如何设置安全的HTTP凭证存储，参见<<_credential_caching>>。

==== The SSH Protocol SSH协议

(((protocols, SSH)))
A common transport protocol for Git when self-hosting is over SSH.
This is because SSH access to servers is already set up in most places – and if it isn't, it's easy to do.
SSH is also an authenticated network protocol; and because it's ubiquitous, it's generally easy to set up and use.
Git 使用的传输协议中最常见的可能就是 SSH 了。这是因为大多数环境已经支持通过 SSH 对服务器的访问 — 即便还没有，架设起来也很容易。SSH 同时也是一个验证授权的网络协议；而因为其普遍性，一般架设和使用都很容易。

To clone a Git repository over SSH, you can specify ssh:// URL like this:
通过 SSH 克隆一个 Git 仓库，你可以像下面这样给出 ssh:// 的 URL：

[source,console]
----
$ git clone ssh://user@server/project.git
----

Or you can use the shorter scp-like syntax for the SSH protocol:
或者不指明某个协议 — 这时 Git 会默认使用 SSH ：

[source,console]
----
$ git clone user@server:project.git
----

You can also not specify a user, and Git assumes the user you're currently logged in as.
如果不指明用户，Git 会默认使用当前登录的用户名连接服务器。

===== The Pros 优点

The pros of using SSH are many.
First, SSH is relatively easy to set up – SSH daemons are commonplace, many network admins have experience with them, and many OS distributions are set up with them or have tools to manage them.
Next, access over SSH is secure – all data transfer is encrypted and authenticated.
Last, like the HTTP/S, Git and Local protocols, SSH is efficient, making the data as compact as possible before transferring it.
使用 SSH 的好处有很多。首先，SSH相对易于配置 —— SSH守护进程很常见，很多网络管理员都有一些使用经验，而且很多操作系统都自带了它或者相关的管理工具。其次，通过 SSH 进行访问是安全的 —— 所有数据传输都是加密和授权的。最后，和 HTTP/S、Git 及本地协议一样，SSH 也很高效，会在传输之前尽可能压缩数据。

===== The Cons 缺点

The negative aspect of SSH is that you can't serve anonymous access of your repository over it.
People must have access to your machine over SSH to access it, even in a read-only capacity, which doesn't make SSH access conducive to open source projects.
If you're using it only within your corporate network, SSH may be the only protocol you need to deal with.
If you want to allow anonymous read-only access to your projects and also want to use SSH, you’ll have to set up SSH for you to push over but something else for others to fetch over.
SSH 的限制在于你不能通过它实现仓库的匿名访问。即使仅为读取数据，人们也必须在能通过 SSH 访问服务器的前提下才能访问仓库，这使得 SSH 不利于开源的项目。如果你仅仅在公司网络里使用，SSH 可能是你唯一需要使用的协议。如果想允许对项目的匿名只读访问，那么除了为自己推送而架设 SSH 协议之外，还需要支持其他协议以便他人访问读取。

==== The Git Protocol Git 协议

(((protocols, git)))
Next is the Git protocol.
This is a special daemon that comes packaged with Git; it listens on a dedicated port (9418) that provides a service similar to the SSH protocol, but with absolutely no authentication.
In order for a repository to be served over the Git protocol, you must create the `git-daemon-export-ok` file – the daemon won't serve a repository without that file in it – but other than that there is no security.
Either the Git repository is available for everyone to clone or it isn't.
This means that there is generally no pushing over this protocol.
You can enable push access; but given the lack of authentication, if you turn on push access, anyone on the internet who finds your project's URL could push to your project.
Suffice it to say that this is rare.
接下来是 Git 协议。这是一个包含在 Git 软件包中的特殊守护进程；它会监听一个提供类似于 SSH 服务的专用端口（9418），而无需任何授权。打算支持 Git 协议的仓库，需要先创建 git-daemon-export-ok 文件 — 它是协议进程提供仓库服务的必要条件 — 但除此之外该服务没有什么安全措施。要么所有人都能克隆 Git 仓库，要么谁也不能。这也意味着该协议通常不能用来进行推送。你可以允许推送操作；然而由于没有授权机制，一旦允许该操作，网络上任何一个知道项目 URL 的人将都有推送权限。不用说，这是十分罕见的情况。

===== The Pros 优点

The Git protocol is often the fastest network transfer protocol available.
If you’re serving a lot of traffic for a public project or serving a very large project that doesn't require user authentication for read access, it’s likely that you'll want to set up a Git daemon to serve your project.
It uses the same data-transfer mechanism as the SSH protocol but without the encryption and authentication overhead.
Git 协议是现存最快的传输协议。如果你在提供一个有很大访问量的公共项目，或者一个不需要对读操作进行授权的庞大项目，架设一个 Git 守护进程来供应仓库是个不错的选择。它使用与 SSH 协议相同的数据传输机制，但省去了加密和授权的开销。

===== The Cons 缺点

The downside of the Git protocol is the lack of authentication.
It's generally undesirable for the Git protocol to be the only access to your project.
Generally, you'll pair it with SSH or HTTPS access for the few developers who have push (write) access and have everyone else use `git://` for read-only access.
It's also probably the most difficult protocol to set up.
It must run its own daemon, which requires `xinetd` configuration or the like, which isn't always a walk in the park.
It also requires firewall access to port 9418, which isn't a standard port that corporate firewalls always allow.
Behind big corporate firewalls, this obscure port is commonly blocked.
Git 协议消极的一面是缺少授权机制。用 Git 协议作为访问项目的唯一方法通常是不可取的。一般的做法是，同时提供 SSH 或 HTTPS 接口，让几个开发者拥有推送（写）权限，其他人通过 git:// 拥有只读权限。 Git 协议可能也是最难架设的协议。它要求有单独的守护进程，需要定制 `xinetd` 之类的配置文件，而这些工作就可能不像闲庭信步一般了。该协议还要求防火墙开放 9418 端口，而企业级防火墙一般不允许对这个非标准端口的访问。大型企业级防火墙通常会封锁这个少见的端口。
